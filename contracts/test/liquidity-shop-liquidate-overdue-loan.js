const { expect } = require("chai");
const { ethers, upgrades } = require("hardhat");
const { LOAN_STATUS, MINIMUM_BASKET_SIZE } = require("./utils/consts");

describe("Liquidate overdue loan", function () {
  before(async function () {
    [owner, borrower, lender, alice] = await ethers.getSigners();

    [
      this.escrow,
      this.promissoryNote,
      this.obligationReceipt,
      this.nftyToken,
      this.currency,
      this.nftCollection,
      this.DIAOracle,
    ] = await deployEscrow();

    // escrow
    const nftyLendingFactory = await ethers.getContractFactory("NFTYLending");

    this.alternativeEscrow = await upgrades.deployProxy(nftyLendingFactory, [
      [],
      [],
      this.promissoryNote.address,
      this.obligationReceipt.address,
      this.nftyToken.address,
      this.DIAOracle.address,
    ]);
    await this.alternativeEscrow.deployed();

    // create liquidity shop
    this.interestA = 20; // Interest percentage that borrower has to pay
    this.interestB = 30;
    this.interestC = 40;
    const maxOffer = ethers.BigNumber.from(10).pow(18).mul(1000); // Max offer set by the lender for this liquidity shop
    const liquidityShopName = "My-Shop";
    const [automaticApproval, allowRefinancingTerms] = [false, true];
    const liquidityAmount = MINIMUM_BASKET_SIZE.add(
      ethers.BigNumber.from(10).pow(18).mul(20000)
    ); // currency tokens

    // Transfer liquidity amount to lender so it can create the shop
    await this.currency.transfer(lender.address, liquidityAmount);

    // Approve liquidity to create shop
    await this.currency
      .connect(lender)
      .approve(this.escrow.address, liquidityAmount);

    const createLiquidityShopTx = await this.escrow
      .connect(lender)
      .createLiquidityShop(
        liquidityShopName,
        this.currency.address,
        this.nftCollection.address,
        liquidityAmount,
        this.interestA,
        this.interestB,
        this.interestC,
        maxOffer,
        automaticApproval,
        allowRefinancingTerms
      );
    const createLiquidityShopResponse = await createLiquidityShopTx.wait();

    this.liquidityShopCreatedEventData =
      createLiquidityShopResponse.events.find(
        (event) => event.event == "LiquidityShopCreated"
      ).args;

    const nftyTokenSymbol = await this.nftyToken.symbol();
    const currencySymbol = await this.currency.symbol();

    // Update the timestamp of the price, otherwise it will fail since other tests change the timestamp
    await updateOracleValue(currencySymbol + "/USD");
    await updateOracleValue(nftyTokenSymbol + "/USD");

    const platformFees = await this.escrow.platformFees();

    // Borrower fees in percentage
    this.borrowerFee = platformFees.borrowerPercentage;

    // Platform fees in percentage
    this.platformFee = platformFees.platformPercentage;

    // Platform fees that can be withdrawn (in NFTY tokens)
    this.platformBalance = ethers.BigNumber.from(0);
  });

  before(async function () {
    this.offer = {
      shopId: this.liquidityShopCreatedEventData.id,
      collateral: this.nftCollection,
      loanDuration: 30, // Days
      loanAmount: this.liquidityShopCreatedEventData.maxOffer.mul(4).div(100),
    };
    this.loan = await acceptOffer(
      borrower,
      lender,
      this.escrow,
      this.offer,
      this.nftyToken,
      this.currency.address
    );

    this.platformBalance = this.platformBalance.add(
      this.loan.fees.mul(this.platformFee).div(100)
    );
  });

  it("Expect to fail because not valid loan id", async function () {
    const invalidNFTYNotesId = 2;
    expect(this.loan.nftyNotesId).to.not.equal(invalidNFTYNotesId);
    await expect(
      this.escrow.connect(lender).liquidateOverdueLoan(invalidNFTYNotesId)
    ).to.be.revertedWith("invalid promissory note");
  });

  it("Expect to fail because not valid loan coordinator", async function () {
    await expect(
      this.alternativeEscrow
        .connect(lender)
        .liquidateOverdueLoan(this.loan.nftyNotesId)
    ).to.be.revertedWith("not loan coordinator");
  });

  it("Expect to fail because promissory note was not generated by the expected loan coordinator", async function () {
    const invalidLoanId = 2;
    expect(this.loan.loanId).to.not.equal(invalidLoanId);

    const encodedLoan = ethers.utils.solidityPack(["uint256"], [invalidLoanId]);

    await this.promissoryNote.setLoanCoordinator(owner.address);

    await this.promissoryNote.mint(lender.address, invalidLoanId, encodedLoan);

    await expect(
      this.escrow.connect(lender).liquidateOverdueLoan(invalidLoanId)
    ).to.be.revertedWith("not loan coordinator");
  });

  it("Expect to fail because loan not expired", async function () {
    const currentBlock = await ethers.provider.getBlock(
      await ethers.provider.getBlockNumber()
    );

    const acceptOfferBlock = await ethers.provider.getBlock(
      this.loan.blockNumber
    );

    // Expect loan expiration time to be greater than current time
    expect(
      acceptOfferBlock.timestamp + 60 * 60 * 24 * this.offer.loanDuration
    ).to.be.greaterThan(currentBlock.timestamp);

    await expect(
      this.escrow.connect(lender).liquidateOverdueLoan(this.loan.nftyNotesId)
    ).to.be.revertedWith("loan not yet expired");
  });

  it("Expect to fail because only owner of the promissory note can liquidate loan", async function () {
    const promissoryNoteOwner = await this.promissoryNote.ownerOf(
      this.loan.nftyNotesId
    );

    expect(promissoryNoteOwner).to.not.equal(alice.address);

    await expect(
      this.escrow.connect(alice).liquidateOverdueLoan(this.loan.nftyNotesId)
    ).to.be.revertedWith("not promissory note owner");
  });

  it("Expect to fail because promissory note was transfered", async function () {
    await this.promissoryNote
      .connect(lender)
      .transferFrom(lender.address, alice.address, this.loan.nftyNotesId);

    await expect(
      this.escrow.connect(lender).liquidateOverdueLoan(this.loan.nftyNotesId)
    ).to.be.revertedWith("not promissory note owner");
  });

  describe("After loan expiration", function () {
    let nonce = 2;
    beforeEach(async function () {
      // Since we are creating an offer each time, we need a new nonce
      nonce++;

      const offer = {
        shopId: this.liquidityShopCreatedEventData.id,
        loanDuration: 60, // Days
        collateral: this.nftCollection,
        loanAmount: this.liquidityShopCreatedEventData.maxOffer
          .mul(20)
          .div(100),
      };

      const nftyTokenSymbol = await this.nftyToken.symbol();
      const currencySymbol = await this.currency.symbol();

      // Update the timestamp of the price, otherwise it will fail since other tests change the timestamp
      await updateOracleValue(currencySymbol + "/USD");
      await updateOracleValue(nftyTokenSymbol + "/USD");

      this.loan = await acceptOffer(
        borrower,
        lender,
        this.escrow,
        offer,
        this.nftyToken,
        this.currency.address,
        { nonce: nonce, expiry: 180 }
      );

      this.platformBalance = this.platformBalance.add(
        this.loan.fees.mul(this.platformFee).div(100)
      );

      this.lending = {
        escrow: this.escrow,
        promissoryNote: this.promissoryNote,
        obligationReceipt: this.obligationReceipt,
        nftCollection: this.nftCollection,
      };

      // Expire loan so lender can claim NFT
      const currentNewDate = 60 * 24 * 60 * 60;
      // Add 60 days to current time so loan has expired
      await ethers.provider.send("evm_increaseTime", [currentNewDate]);
    });

    it("should fail if contract is paused", async function () {
      await this.escrow.setPaused(true);

      await expect(
        this.escrow.connect(lender).liquidateOverdueLoan(this.loan.nftyNotesId)
      ).to.be.revertedWith("Pausable: paused");

      await this.escrow.setPaused(false);
    });

    it("Expect to successfully claim NFT", async function () {
      await liquidateAndVerify(this.lending, this.loan, lender);

      this.platformBalance = this.platformBalance.add(
        this.loan.fees.mul(this.borrowerFee).div(100)
      );
    });

    it("Expect to claim NFT with new promissory note owner", async function () {
      await this.promissoryNote
        .connect(lender)
        .transferFrom(lender.address, alice.address, this.loan.nftyNotesId);

      await liquidateAndVerify(this.lending, this.loan, alice);

      this.platformBalance = this.platformBalance.add(
        this.loan.fees.mul(this.borrowerFee).div(100)
      );
    });

    it("Expect to fail because loan not active", async function () {
      await expect(
        this.escrow.connect(lender).liquidateOverdueLoan(this.loan.nftyNotesId)
      ).to.emit(this.escrow, "LiquidatedOverdueLoan");

      await expect(
        this.escrow.connect(lender).liquidateOverdueLoan(this.loan.nftyNotesId)
      ).to.be.revertedWith("invalid promissory note");

      this.platformBalance = this.platformBalance.add(
        this.loan.fees.mul(this.borrowerFee).div(100)
      );
    });

    it("should withdraw expected platform fees", async function () {
      await withdrawPlatformFees(
        this.nftyToken,
        alice.address,
        this.escrow,
        owner,
        this.platformBalance
      );
    });
  });
});

async function liquidateAndVerify(lendingData, loan, lender) {
  const { escrow, promissoryNote, obligationReceipt, nftCollection } =
    lendingData;

  const initialLoan = await escrow.loans(loan.id);

  const tx = await escrow
    .connect(lender)
    .liquidateOverdueLoan(loan.nftyNotesId);
  const response = await tx.wait();

  await expect(tx).to.emit(escrow, "LiquidatedOverdueLoan");

  // Lender should have NFT
  expect(await nftCollection.ownerOf(loan.collateralId)).equal(lender.address);
  // Obligation receipt should not exist
  await expect(obligationReceipt.ownerOf(loan.nftyNotesId)).to.be.revertedWith(
    "ERC721: invalid token ID"
  );
  // Promissory note should not exist
  await expect(promissoryNote.ownerOf(loan.nftyNotesId)).to.be.revertedWith(
    "ERC721: invalid token ID"
  );

  // check event data
  const liquidatedOverdueLoanEventData = response.events.find(
    (event) => event.event == "LiquidatedOverdueLoan"
  ).args;
  // liquidated shop ID should match shop that issued loan
  expect(liquidatedOverdueLoanEventData.liquidityShopId).to.equal(
    loan.liquidityShopId
  );
  // Id of the promissory and obligation note that were burned
  expect(liquidatedOverdueLoanEventData.nftyNotesId).to.equal(loan.nftyNotesId);
  // liquidated loan ID should match ID for loan created by the original offer
  expect(liquidatedOverdueLoanEventData.loanId).to.equal(loan.id);
  // liquidated loan collateral address should match allowed address for shop that issued loan
  expect(liquidatedOverdueLoanEventData.nftCollateralId).to.equal(
    loan.collateralId
  );
  // liquidated loan promissory note owner should match liquidate caller
  expect(liquidatedOverdueLoanEventData.promissoryNoteOwner).to.equal(
    lender.address
  );

  // check storage
  const storageLoan = await escrow.loans(loan.id);
  expect(storageLoan.amount).to.equal(initialLoan.amount);
  expect(storageLoan.remainder).to.equal(initialLoan.remainder);
  expect(storageLoan.duration).to.equal(initialLoan.duration);
  expect(storageLoan.startTime).to.equal(initialLoan.startTime);
  expect(storageLoan.nftCollateralId).to.equal(initialLoan.nftCollateralId);
  expect(storageLoan.fee).to.equal(initialLoan.fee);
  expect(storageLoan.status).to.equal(LOAN_STATUS.RESOLVED);
  expect(storageLoan.liquidityShopId).to.equal(initialLoan.liquidityShopId);
  expect(storageLoan.nftyNotesId).to.equal(initialLoan.nftyNotesId);
  expect(storageLoan.platformFees.lenderPercentage).to.equal(
    initialLoan.platformFees.lenderPercentage
  );
  expect(storageLoan.platformFees.platformPercentage).to.equal(
    initialLoan.platformFees.platformPercentage
  );
  expect(storageLoan.platformFees.borrowerPercentage).to.equal(
    initialLoan.platformFees.borrowerPercentage
  );
}
