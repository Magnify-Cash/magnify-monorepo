import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { createLoan, deployNftyLending } from "../utils/fixtures";

describe("Liquidate overdue loan", () => {
  it("should fail for invalid NFTY notes id", async () => {
    const { nftyLending, lender, nftyNotesId } = await loadFixture(createLoan);

    const invalidNftyNotesId = 1;
    expect(invalidNftyNotesId).to.not.equal(nftyNotesId);

    await expect(
      nftyLending.connect(lender).liquidateOverdueLoan(invalidNftyNotesId)
    ).to.be.revertedWith("invalid promissory note");
  });

  it("should fail for invalid loan coordinator", async () => {
    const { lender, nftyNotesId } = await loadFixture(createLoan);
    const { nftyLending } = await deployNftyLending();

    await expect(
      nftyLending.connect(lender).liquidateOverdueLoan(nftyNotesId)
    ).to.be.revertedWith("not loan coordinator");
  });

  it("Expect to fail because promissory note was not generated by the expected loan coordinator", async () => {
    const invalidLoanId = 2;
    expect(this.loan.loanId).to.not.equal(invalidLoanId);

    const encodedLoan = ethers.utils.solidityPack(["uint256"], [invalidLoanId]);

    await this.promissoryNote.setLoanCoordinator(owner.address);

    await this.promissoryNote.mint(lender.address, invalidLoanId, encodedLoan);

    await expect(
      this.escrow.connect(lender).liquidateOverdueLoan(invalidLoanId)
    ).to.be.revertedWith("not loan coordinator");
  });

  it("Expect to fail because loan not expired", async () => {
    const currentBlock = await ethers.provider.getBlock(
      await ethers.provider.getBlockNumber()
    );

    const acceptOfferBlock = await ethers.provider.getBlock(
      this.loan.blockNumber
    );

    // Expect loan expiration time to be greater than current time
    expect(
      acceptOfferBlock.timestamp + 60 * 60 * 24 * this.offer.loanDuration
    ).to.be.greaterThan(currentBlock.timestamp);

    await expect(
      this.escrow.connect(lender).liquidateOverdueLoan(this.loan.nftyNotesId)
    ).to.be.revertedWith("loan not yet expired");
  });

  it("Expect to fail because only owner of the promissory note can liquidate loan", async () => {
    const promissoryNoteOwner = await this.promissoryNote.ownerOf(
      this.loan.nftyNotesId
    );

    expect(promissoryNoteOwner).to.not.equal(alice.address);

    await expect(
      this.escrow.connect(alice).liquidateOverdueLoan(this.loan.nftyNotesId)
    ).to.be.revertedWith("not promissory note owner");
  });

  it("Expect to fail because promissory note was transfered", async () => {
    await this.promissoryNote
      .connect(lender)
      .transferFrom(lender.address, alice.address, this.loan.nftyNotesId);

    await expect(
      this.escrow.connect(lender).liquidateOverdueLoan(this.loan.nftyNotesId)
    ).to.be.revertedWith("not promissory note owner");
  });

  describe("After loan expiration", function () {
    let nonce = 2;
    beforeEach(async function () {
      // Since we are creating an offer each time, we need a new nonce
      nonce++;

      const offer = {
        shopId: this.liquidityShopCreatedEventData.id,
        loanDuration: 60, // Days
        collateral: this.nftCollection,
        loanAmount: this.liquidityShopCreatedEventData.maxOffer
          .mul(20)
          .div(100),
      };

      const nftyTokenSymbol = await this.nftyToken.symbol();
      const currencySymbol = await this.currency.symbol();

      // Update the timestamp of the price, otherwise it will fail since other tests change the timestamp
      await updateOracleValue(currencySymbol + "/USD");
      await updateOracleValue(nftyTokenSymbol + "/USD");

      this.loan = await acceptOffer(
        borrower,
        lender,
        this.escrow,
        offer,
        this.nftyToken,
        this.currency.address,
        { nonce: nonce, expiry: 180 }
      );

      this.platformBalance = this.platformBalance.add(
        this.loan.fees.mul(this.platformFee).div(100)
      );

      this.lending = {
        escrow: this.escrow,
        promissoryNote: this.promissoryNote,
        obligationReceipt: this.obligationReceipt,
        nftCollection: this.nftCollection,
      };

      // Expire loan so lender can claim NFT
      const currentNewDate = 60 * 24 * 60 * 60;
      // Add 60 days to current time so loan has expired
      await ethers.provider.send("evm_increaseTime", [currentNewDate]);
    });

    it("should fail if contract is paused", async function () {
      await this.escrow.setPaused(true);

      await expect(
        this.escrow.connect(lender).liquidateOverdueLoan(this.loan.nftyNotesId)
      ).to.be.revertedWith("Pausable: paused");

      await this.escrow.setPaused(false);
    });

    it("Expect to successfully claim NFT", async function () {
      await liquidateAndVerify(this.lending, this.loan, lender);

      this.platformBalance = this.platformBalance.add(
        this.loan.fees.mul(this.borrowerFee).div(100)
      );
    });

    it("Expect to claim NFT with new promissory note owner", async function () {
      await this.promissoryNote
        .connect(lender)
        .transferFrom(lender.address, alice.address, this.loan.nftyNotesId);

      await liquidateAndVerify(this.lending, this.loan, alice);

      this.platformBalance = this.platformBalance.add(
        this.loan.fees.mul(this.borrowerFee).div(100)
      );
    });

    it("Expect to fail because loan not active", async function () {
      await expect(
        this.escrow.connect(lender).liquidateOverdueLoan(this.loan.nftyNotesId)
      ).to.emit(this.escrow, "LiquidatedOverdueLoan");

      await expect(
        this.escrow.connect(lender).liquidateOverdueLoan(this.loan.nftyNotesId)
      ).to.be.revertedWith("invalid promissory note");

      this.platformBalance = this.platformBalance.add(
        this.loan.fees.mul(this.borrowerFee).div(100)
      );
    });

    it("should withdraw expected platform fees", async function () {
      await withdrawPlatformFees(
        this.nftyToken,
        alice.address,
        this.escrow,
        owner,
        this.platformBalance
      );
    });
  });
});

async function liquidateAndVerify(lendingData, loan, lender) {
  const { escrow, promissoryNote, obligationReceipt, nftCollection } =
    lendingData;

  const initialLoan = await escrow.loans(loan.id);

  const tx = await escrow
    .connect(lender)
    .liquidateOverdueLoan(loan.nftyNotesId);
  const response = await tx.wait();

  await expect(tx).to.emit(escrow, "LiquidatedOverdueLoan");

  // Lender should have NFT
  expect(await nftCollection.ownerOf(loan.collateralId)).equal(lender.address);
  // Obligation receipt should not exist
  await expect(obligationReceipt.ownerOf(loan.nftyNotesId)).to.be.revertedWith(
    "ERC721: invalid token ID"
  );
  // Promissory note should not exist
  await expect(promissoryNote.ownerOf(loan.nftyNotesId)).to.be.revertedWith(
    "ERC721: invalid token ID"
  );

  // check event data
  const liquidatedOverdueLoanEventData = response.events.find(
    (event) => event.event == "LiquidatedOverdueLoan"
  ).args;
  // liquidated shop ID should match shop that issued loan
  expect(liquidatedOverdueLoanEventData.liquidityShopId).to.equal(
    loan.liquidityShopId
  );
  // Id of the promissory and obligation note that were burned
  expect(liquidatedOverdueLoanEventData.nftyNotesId).to.equal(loan.nftyNotesId);
  // liquidated loan ID should match ID for loan created by the original offer
  expect(liquidatedOverdueLoanEventData.loanId).to.equal(loan.id);
  // liquidated loan collateral address should match allowed address for shop that issued loan
  expect(liquidatedOverdueLoanEventData.nftCollateralId).to.equal(
    loan.collateralId
  );
  // liquidated loan promissory note owner should match liquidate caller
  expect(liquidatedOverdueLoanEventData.promissoryNoteOwner).to.equal(
    lender.address
  );

  // check storage
  const storageLoan = await escrow.loans(loan.id);
  expect(storageLoan.amount).to.equal(initialLoan.amount);
  expect(storageLoan.remainder).to.equal(initialLoan.remainder);
  expect(storageLoan.duration).to.equal(initialLoan.duration);
  expect(storageLoan.startTime).to.equal(initialLoan.startTime);
  expect(storageLoan.nftCollateralId).to.equal(initialLoan.nftCollateralId);
  expect(storageLoan.fee).to.equal(initialLoan.fee);
  expect(storageLoan.status).to.equal(LOAN_STATUS.RESOLVED);
  expect(storageLoan.liquidityShopId).to.equal(initialLoan.liquidityShopId);
  expect(storageLoan.nftyNotesId).to.equal(initialLoan.nftyNotesId);
  expect(storageLoan.platformFees.lenderPercentage).to.equal(
    initialLoan.platformFees.lenderPercentage
  );
  expect(storageLoan.platformFees.platformPercentage).to.equal(
    initialLoan.platformFees.platformPercentage
  );
  expect(storageLoan.platformFees.borrowerPercentage).to.equal(
    initialLoan.platformFees.borrowerPercentage
  );
}
